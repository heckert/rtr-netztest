import logging
import operator
import pandas as pd


valid_operators = {
    'equals': operator.eq,
    'greater': operator.gt,
    'greater-or-equal': operator.ge,
    'less': operator.lt,
    'less-or-equal': operator.le
}


def parse_filters(df: pd.DataFrame, filters: dict) -> pd.Series:
    """Get filters from config and create single pandas mask

    Args:
        df (pandas.DataFrame): Dataframe to be filtered.
        filters (dict): Which filters to apply.

    Returns:
        pandas.Series: Mask to filter DataFrame.
    """

    # Evaluate operators passed in filters-dict
    passed_operators = set()
    operator_dicts = filters.values()
    for operator_dict in operator_dicts:
        for key in operator_dict.keys():
            passed_operators.add(key)

    allowed_operators = set(valid_operators.keys())
    intersect_allowed = set.intersection(passed_operators, allowed_operators)

    if intersect_allowed < passed_operators:
        raise ValueError('Keys for `filters` must be in {}'.format(
            ', '.join(allowed_operators))
        )

    # Iterate through passed filters and create
    # single pandas mask
    trues = pd.Series([True for _ in range(df.shape[0])])
    falses = pd.Series([False for _ in range(df.shape[0])])

    ands = trues.copy()
    for colname, operator_dict in filters.items():
        ors = falses.copy()
        for op, values in operator_dict.items():
            for value in values:
                comparison_func = valid_operators.get(op)
                tmp_cond = comparison_func(df[colname], value)

                ors = ors | tmp_cond

        ands = ands & ors

    return ands


def apply_filters(df: pd.DataFrame = None,
                  filters: dict = None) -> pd.DataFrame:

    """Wrapper function to filter DataFrame according to mask
        generated by `src.utils.preprocessing.parse_filters`.

    Main purpose of the wrapper is to provide logging capabilites.

    Args:
        df (pd.DataFrame): DataFrame to be filtered.
        filters (dict): Which filters to apply.

    Returns:
        Filtered DataFrame.
    """

    # Select only relevant technologies
    logging.debug(f'Filtering for {filters}')
    filter_ = parse_filters(df, filters)

    # Log how many cases are filtered
    counts = filter_.value_counts().to_dict()
    n_not_selected = counts.get(False)
    if n_not_selected is None:
        n_not_selected = 0

    logging.debug(
        'Filtered out {negative:,} of {total:,} ({percentage}%)'.format(
            negative=n_not_selected, total=len(df),
            percentage=round(n_not_selected/len(df)*100, 1)
        )
    )

    df = df.copy()
    df = df[filter_]

    return df
